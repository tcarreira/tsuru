{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tsuru","title":"Home"},{"location":"#tsuru","text":"","title":"Tsuru"},{"location":"admin/local_environment/helm/","text":"Installing Tsuru in a local Kubernetes cluster with Helm All steps in this guide were done in Kubernetes v1.20.0. While it might work for almost all Kubernetes versions, some versions may break something. Feel free to report us in that case. Prerequisites Minikube kubectl Helm Jumpstarting the cluster Tsuru has a Makefile recipe ( make local ) to locally run a minikube cluster on your machine, but feel free to bootstrap your minikube cluster anyway you want. Hardware Requirements 2 CPUs or more 12GB of free memory 20GB of free disk space Installing the helm chart Adding tsuru's helm chart helm repo add tsuru https://tsuru.github.io/charts Installing the chart helm install tsuru tsuru/tsuru-stack --create-namespace --namespace tsuru-system Congratulations you have tsuru installed and runnning on your cluster! Admin Configuration Create the admin user on tsuru: kubectl exec -it -n tsuru-system deploy/tsuru-api -- tsurud root user create admin@admin.com You can replace admin@admin.com with any email you'd prefer Use Port-forward to access tsuru and ingress controller locally: kubectl port-forward --namespace tsuru-system svc/tsuru-api 8080:80 & kubectl port-forward --namespace tsuru-system svc/tsuru-ingress-nginx-controller 8890:80 & If you specified a port when you installed helm it will have to use the same port in tsuru-ingress-nginx-controller. Add the localhost to tsuru target and log in: tsuru target-add default https://localhost:8080 -s tsuru login Create a team: tsuru team create admin Add at least one platform: tsuru platform add go This is just an example, you could add python or other platforms i.e: tsuru platform add python Optional Steps Create and Deploy tsuru-dashboard app: tsuru app create dashboard tsuru app deploy -a dashboard --image tsuru/dashboard Create an app to test: mkdir example-go cd example-go git clone https://github.com/tsuru/platforms.git cd platforms/examples/go tsuru app create example-go go tsuru app deploy -a example-go","title":"With Helm"},{"location":"admin/local_environment/helm/#installing-tsuru-in-a-local-kubernetes-cluster-with-helm","text":"All steps in this guide were done in Kubernetes v1.20.0. While it might work for almost all Kubernetes versions, some versions may break something. Feel free to report us in that case.","title":"Installing Tsuru in a local Kubernetes cluster with Helm"},{"location":"admin/local_environment/helm/#prerequisites","text":"Minikube kubectl Helm","title":"Prerequisites"},{"location":"admin/local_environment/helm/#jumpstarting-the-cluster","text":"Tsuru has a Makefile recipe ( make local ) to locally run a minikube cluster on your machine, but feel free to bootstrap your minikube cluster anyway you want.","title":"Jumpstarting the cluster"},{"location":"admin/local_environment/helm/#hardware-requirements","text":"2 CPUs or more 12GB of free memory 20GB of free disk space","title":"Hardware Requirements"},{"location":"admin/local_environment/helm/#installing-the-helm-chart","text":"Adding tsuru's helm chart helm repo add tsuru https://tsuru.github.io/charts Installing the chart helm install tsuru tsuru/tsuru-stack --create-namespace --namespace tsuru-system Congratulations you have tsuru installed and runnning on your cluster!","title":"Installing the helm chart"},{"location":"admin/local_environment/helm/#admin-configuration","text":"Create the admin user on tsuru: kubectl exec -it -n tsuru-system deploy/tsuru-api -- tsurud root user create admin@admin.com You can replace admin@admin.com with any email you'd prefer Use Port-forward to access tsuru and ingress controller locally: kubectl port-forward --namespace tsuru-system svc/tsuru-api 8080:80 & kubectl port-forward --namespace tsuru-system svc/tsuru-ingress-nginx-controller 8890:80 & If you specified a port when you installed helm it will have to use the same port in tsuru-ingress-nginx-controller. Add the localhost to tsuru target and log in: tsuru target-add default https://localhost:8080 -s tsuru login Create a team: tsuru team create admin Add at least one platform: tsuru platform add go This is just an example, you could add python or other platforms i.e: tsuru platform add python","title":"Admin Configuration"},{"location":"admin/local_environment/helm/#optional-steps","text":"Create and Deploy tsuru-dashboard app: tsuru app create dashboard tsuru app deploy -a dashboard --image tsuru/dashboard Create an app to test: mkdir example-go cd example-go git clone https://github.com/tsuru/platforms.git cd platforms/examples/go tsuru app create example-go go tsuru app deploy -a example-go","title":"Optional Steps"},{"location":"admin/local_environment/make-local/","text":"Installing Tsuru locally This guide will walk you through running the tsuru api locally and attaching it to your running kubernetes cluster Prerequisites Minikube (this can be optional if you already have a cluster running) kubectl Git clone First things thirst, please clone tsuru repository and cd into it: git clone https://github.com/tsuru/tsuru.git & cd tsuru Jumpstarting the cluster (optional) Tsuru has a Makefile recipe make local to locally run a minikube cluster on your machine, but feel free to bootstrap your cluster anyway you want. It's important to make sure the tsuru api has access to the services running inside the cluster and can talk to the Kubernetes api, this can be easily achieved by running the cluster using the none driver when running minikube If you just want to test things out locally we highly recommend the usage of make local for simplicity and support Run the tsuru api If you've ran the make local recipe and got no errors the api should already be up and running. If you decide to create the cluster on your behalf, you still have to build and run the api, there's also a recipe for that: make local-api Admin Configuration Edit the host paramater inside etc/tsuru-local.conf and replace it with your own local IP To find out your local IP either run ifconfig or the newer ip --addr command Create the admin user on tsuru: tsurud root user create admin@admin.com You can replace admin@admin.com with any email you'd prefer Add the localhost to tsuru target and log in using your credentials created in step 1: tsuru target-add default https://localhost:8080 -s tsuru login Create a team: tsuru team create admin-team Create a pool: tsuru pool create kubepool --provisioner=kubernetes --default=true Add your running cluster to tsuru: tsuru cluster add minikube kubernetes --addr https://`minikube ip`:8443 --cacert $HOME/.minikube/ca.crt --clientcert $HOME/.minikube/profiles/minikube/apiserver.crt --clientkey $HOME/.minikube/profiles/minikube/apiserver.key --pool kubepool Check your node IP: tsuru node list -f tsuru.io/cluster=minikube Register your node IP as a member of kubepool: tsuru node update <node ip> pool=kubepool Optional Steps Add a platform: tsuru platform add go Create and Deploy tsuru-dashboard app: tsuru app create dashboard tsuru app deploy -a dashboard --image tsuru/dashboard Create an app to test: mkdir example-go cd example-go git clone https://github.com/tsuru/platforms.git cd platforms/examples/go tsuru app create example-go go tsuru app deploy -a example-go","title":"With Makefile"},{"location":"admin/local_environment/make-local/#installing-tsuru-locally","text":"This guide will walk you through running the tsuru api locally and attaching it to your running kubernetes cluster","title":"Installing Tsuru locally"},{"location":"admin/local_environment/make-local/#prerequisites","text":"Minikube (this can be optional if you already have a cluster running) kubectl","title":"Prerequisites"},{"location":"admin/local_environment/make-local/#git-clone","text":"First things thirst, please clone tsuru repository and cd into it: git clone https://github.com/tsuru/tsuru.git & cd tsuru","title":"Git clone"},{"location":"admin/local_environment/make-local/#jumpstarting-the-cluster-optional","text":"Tsuru has a Makefile recipe make local to locally run a minikube cluster on your machine, but feel free to bootstrap your cluster anyway you want. It's important to make sure the tsuru api has access to the services running inside the cluster and can talk to the Kubernetes api, this can be easily achieved by running the cluster using the none driver when running minikube If you just want to test things out locally we highly recommend the usage of make local for simplicity and support","title":"Jumpstarting the cluster (optional)"},{"location":"admin/local_environment/make-local/#run-the-tsuru-api","text":"If you've ran the make local recipe and got no errors the api should already be up and running. If you decide to create the cluster on your behalf, you still have to build and run the api, there's also a recipe for that: make local-api","title":"Run the tsuru api"},{"location":"admin/local_environment/make-local/#admin-configuration","text":"Edit the host paramater inside etc/tsuru-local.conf and replace it with your own local IP To find out your local IP either run ifconfig or the newer ip --addr command Create the admin user on tsuru: tsurud root user create admin@admin.com You can replace admin@admin.com with any email you'd prefer Add the localhost to tsuru target and log in using your credentials created in step 1: tsuru target-add default https://localhost:8080 -s tsuru login Create a team: tsuru team create admin-team Create a pool: tsuru pool create kubepool --provisioner=kubernetes --default=true Add your running cluster to tsuru: tsuru cluster add minikube kubernetes --addr https://`minikube ip`:8443 --cacert $HOME/.minikube/ca.crt --clientcert $HOME/.minikube/profiles/minikube/apiserver.crt --clientkey $HOME/.minikube/profiles/minikube/apiserver.key --pool kubepool Check your node IP: tsuru node list -f tsuru.io/cluster=minikube Register your node IP as a member of kubepool: tsuru node update <node ip> pool=kubepool","title":"Admin Configuration"},{"location":"admin/local_environment/make-local/#optional-steps","text":"Add a platform: tsuru platform add go Create and Deploy tsuru-dashboard app: tsuru app create dashboard tsuru app deploy -a dashboard --image tsuru/dashboard Create an app to test: mkdir example-go cd example-go git clone https://github.com/tsuru/platforms.git cd platforms/examples/go tsuru app create example-go go tsuru app deploy -a example-go","title":"Optional Steps"},{"location":"references/tsuru.yaml/","text":"Tsuru YAML Voc\u00ea pode configurar Tsuru permite que sua app How can I submit tsuru.yaml ? dfoooooooo","title":"tsuru.yaml"},{"location":"references/tsuru.yaml/#tsuru-yaml","text":"Voc\u00ea pode configurar Tsuru permite que sua app How can I submit tsuru.yaml ? dfoooooooo","title":"Tsuru YAML"},{"location":"user_guides/deploy_using_dockerfile/","text":"Deploy using Dockerfile Tsuru official's platforms don't support every language, framework, or runtime your tech stack may require. It doesn't intend to do so. If you have a setup where the official platforms don't meet your needs, you can deploy your app using its Dockerfile (Containerfile). Comparison: container image x Dockerfile Developer's convenience is the key difference between deploying an app using a container image and Dockerfile. The former requires extra steps on the developer's side, such as building and publishing the container image, the latter doesn't. This guide will walk you through the steps to deploy into an app using a simple Dockerfile. Prerequisites This guide assumes that you have: Tsuru client installed (version must be >= 1.15); Set a Tsuru target (server version must be >= 1.14); Logged into Tsuru; An app (henceforth referred as hello-world-app ) where your user has permission to deploy on. Usage In this example, we are building and deploying a simple application written in Go. You can checkout the complete code used here on samples/dockerfile_v1 . You might take a closer look at Dockerfile and main.go files, but there's no mytery on them. To deploy into application using its Dockerfile, you just need issue the below command: tsuru app deploy -a hello-world --dockerfile ./ The main difference among other types of deploys on Tsuru is the new command argument --dockerfile . The --dockerfile command argument allows you to pass a directory or a specific container file. When you pass a directory, Tsuru client tries to find the container file following these names (order matters): Dockerfile.<app name> (e.g. Dockerfile.hello-world-app ) Containerfile.<app name> (e.g. Containerfile.hello-world-app ) Dockerfile.tsuru Containerfile.tsuru Dockerfile Containerfile Example: tsuru app deploy -a <app name> --dockerfile ./path/to/dir/ When you pass a regular file, Tsuru consider it as the container file - regardless of its file name. Example: tsuru app deploy -a <app name> --dockerfile ./path/to/Dockerfile.custom In both cases, the build context (files passed to the builder where you can refer on COPY / ADD directives) is the current working directory. Otherwise, you can select only the files you want by passing their namely. Example: tsuru app deploy -a <app name> --dockerfile ./path/to/Dockerfile file1.txt file2.txt Advanced tweaks How can I access Tsuru env vars during container image build? You're able to import the env vars configured on Tsuru app while running the deploy with Dockerfile. To do so, you just need append the following snippet in the Dockerfile. RUN --mount = type = secret,id = tsuru-app-envvars,target = /var/run/secrets/envs.sh \\ && . /var/run/secrets/envs.sh \\ ... following commands in this multi-command line are able to see the env vars from Tsuru NOTE : That's a bit different than defining ENV directive, specially because they're not stored in the image layers. Limitations You cannot use distroless based images on your final container image - although on intermediary stages is fine. 1 There's no support for setting build arguments. There's no support to specify a particular platform - the only platform supported is linux/amd64 . Tsuru requires a shell intepreter (e.g. sh or bash ) to run hooks, app shell, etc. \u21a9","title":"Using Dockerfile"},{"location":"user_guides/deploy_using_dockerfile/#deploy-using-dockerfile","text":"Tsuru official's platforms don't support every language, framework, or runtime your tech stack may require. It doesn't intend to do so. If you have a setup where the official platforms don't meet your needs, you can deploy your app using its Dockerfile (Containerfile). Comparison: container image x Dockerfile Developer's convenience is the key difference between deploying an app using a container image and Dockerfile. The former requires extra steps on the developer's side, such as building and publishing the container image, the latter doesn't. This guide will walk you through the steps to deploy into an app using a simple Dockerfile.","title":"Deploy using Dockerfile"},{"location":"user_guides/deploy_using_dockerfile/#prerequisites","text":"This guide assumes that you have: Tsuru client installed (version must be >= 1.15); Set a Tsuru target (server version must be >= 1.14); Logged into Tsuru; An app (henceforth referred as hello-world-app ) where your user has permission to deploy on.","title":"Prerequisites"},{"location":"user_guides/deploy_using_dockerfile/#usage","text":"In this example, we are building and deploying a simple application written in Go. You can checkout the complete code used here on samples/dockerfile_v1 . You might take a closer look at Dockerfile and main.go files, but there's no mytery on them. To deploy into application using its Dockerfile, you just need issue the below command: tsuru app deploy -a hello-world --dockerfile ./ The main difference among other types of deploys on Tsuru is the new command argument --dockerfile . The --dockerfile command argument allows you to pass a directory or a specific container file. When you pass a directory, Tsuru client tries to find the container file following these names (order matters): Dockerfile.<app name> (e.g. Dockerfile.hello-world-app ) Containerfile.<app name> (e.g. Containerfile.hello-world-app ) Dockerfile.tsuru Containerfile.tsuru Dockerfile Containerfile Example: tsuru app deploy -a <app name> --dockerfile ./path/to/dir/ When you pass a regular file, Tsuru consider it as the container file - regardless of its file name. Example: tsuru app deploy -a <app name> --dockerfile ./path/to/Dockerfile.custom In both cases, the build context (files passed to the builder where you can refer on COPY / ADD directives) is the current working directory. Otherwise, you can select only the files you want by passing their namely. Example: tsuru app deploy -a <app name> --dockerfile ./path/to/Dockerfile file1.txt file2.txt","title":"Usage"},{"location":"user_guides/deploy_using_dockerfile/#advanced-tweaks","text":"","title":"Advanced tweaks"},{"location":"user_guides/deploy_using_dockerfile/#how-can-i-access-tsuru-env-vars-during-container-image-build","text":"You're able to import the env vars configured on Tsuru app while running the deploy with Dockerfile. To do so, you just need append the following snippet in the Dockerfile. RUN --mount = type = secret,id = tsuru-app-envvars,target = /var/run/secrets/envs.sh \\ && . /var/run/secrets/envs.sh \\ ... following commands in this multi-command line are able to see the env vars from Tsuru NOTE : That's a bit different than defining ENV directive, specially because they're not stored in the image layers.","title":"How can I access Tsuru env vars during container image build?"},{"location":"user_guides/deploy_using_dockerfile/#limitations","text":"You cannot use distroless based images on your final container image - although on intermediary stages is fine. 1 There's no support for setting build arguments. There's no support to specify a particular platform - the only platform supported is linux/amd64 . Tsuru requires a shell intepreter (e.g. sh or bash ) to run hooks, app shell, etc. \u21a9","title":"Limitations"}]}